{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stacko Docs Official documentation for the Stacko programming language. New to Stacko? Read the Getting Started page. Want to Learn More? Read the Stack Manipulation guide to better understand how Stacko programs are built. Read the Keyword Reference to see all of Stacko's built-in operations. Want to Contribute? Check out the official GitHub repository .","title":"Home"},{"location":"#stacko-docs","text":"Official documentation for the Stacko programming language.","title":"Stacko Docs"},{"location":"#new-to-stacko","text":"Read the Getting Started page.","title":"New to Stacko?"},{"location":"#want-to-learn-more","text":"Read the Stack Manipulation guide to better understand how Stacko programs are built. Read the Keyword Reference to see all of Stacko's built-in operations.","title":"Want to Learn More?"},{"location":"#want-to-contribute","text":"Check out the official GitHub repository .","title":"Want to Contribute?"},{"location":"getting-started/","text":"Getting Started Download Stacko To begin using Stacko you'll first need to clone it from the official repository . git clone https://github.com/Mercifle/Stacko.git Enter the newly created Stacko directory and run the interpreter using Python3. cd Stacko python3 Stacko.py Install the Interpreter To use the Stacko interpreter from anywhere in your system you'll first need to install it locally. To begin you'll first need to make the Stacko interpreter executable. To do this, run the following command from within the Stacko directory. chmod +x Stacko.py Next add a link to the interpreter to your local bin directory. ln Stacko.py /usr/local/bin/stacko Now, try running the Stacko interpreter from anywhere in your system using the following command. stacko You may need to add /usr/local/bin/ to your path if it is not already included there. This can be done temporarily with the following command. export PATH = $PATH :/usr/local/bin Using this method your local bin directory will remain in your path until you close your current bash session. To make this change permanent simply add the previous command to your .bashrc with the following command. echo \"export PATH= $PATH :/usr/local/bin\" >> ~/.bashrc Run a Script Let's create and run a simple \"Hello, world!\" program using Stacko! The begin, create a new file with either the .stko or the .stacko file extension. So long as the file uses either of the previously listed file extensions a Stacko script can be given any name. For this example we'll name our file HelloWorld.stacko . touch HelloWorld.stacko Open your newly created file and enter the following code. # Write \"Hello, world!\" to stdout \"Hello, world!\" printLine You can run this script using the following command. stacko HelloWorld.stko Congratulations, you've just successfully written and ran your first Stacko script!","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#download-stacko","text":"To begin using Stacko you'll first need to clone it from the official repository . git clone https://github.com/Mercifle/Stacko.git Enter the newly created Stacko directory and run the interpreter using Python3. cd Stacko python3 Stacko.py","title":"Download Stacko"},{"location":"getting-started/#install-the-interpreter","text":"To use the Stacko interpreter from anywhere in your system you'll first need to install it locally. To begin you'll first need to make the Stacko interpreter executable. To do this, run the following command from within the Stacko directory. chmod +x Stacko.py Next add a link to the interpreter to your local bin directory. ln Stacko.py /usr/local/bin/stacko Now, try running the Stacko interpreter from anywhere in your system using the following command. stacko You may need to add /usr/local/bin/ to your path if it is not already included there. This can be done temporarily with the following command. export PATH = $PATH :/usr/local/bin Using this method your local bin directory will remain in your path until you close your current bash session. To make this change permanent simply add the previous command to your .bashrc with the following command. echo \"export PATH= $PATH :/usr/local/bin\" >> ~/.bashrc","title":"Install the Interpreter"},{"location":"getting-started/#run-a-script","text":"Let's create and run a simple \"Hello, world!\" program using Stacko! The begin, create a new file with either the .stko or the .stacko file extension. So long as the file uses either of the previously listed file extensions a Stacko script can be given any name. For this example we'll name our file HelloWorld.stacko . touch HelloWorld.stacko Open your newly created file and enter the following code. # Write \"Hello, world!\" to stdout \"Hello, world!\" printLine You can run this script using the following command. stacko HelloWorld.stko Congratulations, you've just successfully written and ran your first Stacko script!","title":"Run a Script"},{"location":"keywords/","text":"Keyword Reference Text between curly braces ( {} ) represent blocks. A block is a sequence of instructions encased in curly braces in source code. { \"This is a block!\" printLine } Text between less than and greater than symbols ( <> ) represent identifiers in source code. # These are all valid identifiers foo _bar baz13 Text between square brackets ( [] ) is optional. Stack Operations Name Signature Description dup a -- a a Duplicates a . pop a -- Pops a off of the stack. Arithmetic Operations Name Signature Description + a b -- c Returns the sum of a and b . - a b -- c Returns a minus b . * a b -- c Returns the product of a and b . / a b -- c Returns a divided by b . % a b -- c Returns a modulo b . See modular arithmetic . Logical Operations Name Signature Description = a b -- c Returns true if a and b are equal. Returns false otherwise. < a b -- c Returns true if a is less than b . Returns false otherwise. <= a b -- c Returns true if a is less than or equal to b . Returns false otherwise. > a b -- c Returns true if a is greater than b . Returns false otherwise. >= a b -- c Returns true if a is greater than or equal to b . Returns false otherwise. not a -- b Returns the opposite of a . a must be a boolean. Type Operations Name Signature Description toBool a -- b Converts a into a boolean value. toNum a -- b Converts a into a numeric value. toString a -- b Converts a into a string. Assertions Name Signature Description assert a -- Halts execution of the program if a is false. assertEqual a b -- Halts execution of the program if a and b are not equal. assertNotEqual a b -- Halts execution of the program if a and b are equal. List Operations Name Signature Description getElement list index -- elem Returns the element from a list list at index index . System Operations Name Signature Description print a -- Writes contents of a to stdout. printLine a -- Writes contents of a to stdout with a trailing newline character. readLine -- input Returns a single line of input from stdin. waitMore a -- Halts execution of the program for a seconds. a must be a float. Identifier Operations Name Signature Description const <name> a -- Creates a constant with the name <name> and a value of a . var <name> -- Creates a variable with the name <name> . set <name> a -- Assigns the value of a to a variable with the name <name> . <name> -- a Pushes the value of a variable or constant with the name <name> onto the stack. Control Flow Name Signature Description while {body} a -- Continually executes the instructions in {body} so long as a is true. fnn <name> {body} -- Creates a new function with the name <name> . if {body} [else {else-body}] a -- Conditionally executes the instructions in {body} if a is true, otherwise the instructions in {else-body} are executed. <name> Unknown Executes instructions in the body ( {body} ) of a function with the name <name> . Meta Operations Name Signature Description file <file-path> -- Includes the contents of another Stacko file at <file-path> .","title":"Keyword Reference"},{"location":"keywords/#keyword-reference","text":"Text between curly braces ( {} ) represent blocks. A block is a sequence of instructions encased in curly braces in source code. { \"This is a block!\" printLine } Text between less than and greater than symbols ( <> ) represent identifiers in source code. # These are all valid identifiers foo _bar baz13 Text between square brackets ( [] ) is optional.","title":"Keyword Reference"},{"location":"keywords/#stack-operations","text":"Name Signature Description dup a -- a a Duplicates a . pop a -- Pops a off of the stack.","title":"Stack Operations"},{"location":"keywords/#arithmetic-operations","text":"Name Signature Description + a b -- c Returns the sum of a and b . - a b -- c Returns a minus b . * a b -- c Returns the product of a and b . / a b -- c Returns a divided by b . % a b -- c Returns a modulo b . See modular arithmetic .","title":"Arithmetic Operations"},{"location":"keywords/#logical-operations","text":"Name Signature Description = a b -- c Returns true if a and b are equal. Returns false otherwise. < a b -- c Returns true if a is less than b . Returns false otherwise. <= a b -- c Returns true if a is less than or equal to b . Returns false otherwise. > a b -- c Returns true if a is greater than b . Returns false otherwise. >= a b -- c Returns true if a is greater than or equal to b . Returns false otherwise. not a -- b Returns the opposite of a . a must be a boolean.","title":"Logical Operations"},{"location":"keywords/#type-operations","text":"Name Signature Description toBool a -- b Converts a into a boolean value. toNum a -- b Converts a into a numeric value. toString a -- b Converts a into a string.","title":"Type Operations"},{"location":"keywords/#assertions","text":"Name Signature Description assert a -- Halts execution of the program if a is false. assertEqual a b -- Halts execution of the program if a and b are not equal. assertNotEqual a b -- Halts execution of the program if a and b are equal.","title":"Assertions"},{"location":"keywords/#list-operations","text":"Name Signature Description getElement list index -- elem Returns the element from a list list at index index .","title":"List Operations"},{"location":"keywords/#system-operations","text":"Name Signature Description print a -- Writes contents of a to stdout. printLine a -- Writes contents of a to stdout with a trailing newline character. readLine -- input Returns a single line of input from stdin. waitMore a -- Halts execution of the program for a seconds. a must be a float.","title":"System Operations"},{"location":"keywords/#identifier-operations","text":"Name Signature Description const <name> a -- Creates a constant with the name <name> and a value of a . var <name> -- Creates a variable with the name <name> . set <name> a -- Assigns the value of a to a variable with the name <name> . <name> -- a Pushes the value of a variable or constant with the name <name> onto the stack.","title":"Identifier Operations"},{"location":"keywords/#control-flow","text":"Name Signature Description while {body} a -- Continually executes the instructions in {body} so long as a is true. fnn <name> {body} -- Creates a new function with the name <name> . if {body} [else {else-body}] a -- Conditionally executes the instructions in {body} if a is true, otherwise the instructions in {else-body} are executed. <name> Unknown Executes instructions in the body ( {body} ) of a function with the name <name> .","title":"Control Flow"},{"location":"keywords/#meta-operations","text":"Name Signature Description file <file-path> -- Includes the contents of another Stacko file at <file-path> .","title":"Meta Operations"},{"location":"stack-manipulation/","text":"Stack Manipulation The Stack Stacko maintains a list of values throughout its lifetime in a list known as the stack. Values can be appended ( pushed ) and removed ( popped ) from the stack at any time, but can only be done so in a last-in first-out ( LIFO ) order. Values on the stack may be used by certain instructions to perform calculations. These calculations may in turn push more values onto the stack. To understand this a bit better, lets look at the following example program. 10 5 + dup * printLine When Stacko begins to execute a new program it begins with an empty stack. Stack: [ ] Stack will then proceed to execute the first instruction in our program 10 . This instruction pushes the integer value 10 onto the stack. Stack: [ 10 ] The next instruction 5 likewise pushes the integer value 5 onto the stack. Stack: [ 10 5 ] Both the instructions we've seen so far have simply pushed new values onto the stack. The next instruction we'll look is the + instruction. The + instruction (otherwise known as the add instruction) pops two values off of the stack and then pushes their sum onto the stack. Stack Underflow Instructions such as the add instruction may assume a certain number of values currently exist on the stack and can safely be popped off it. This, however, may not always be the case. Because the add instruction must pop two values off of the stack in order to perform its operation successfully, it must assume that at least 2 values exist on the stack when it is called. If these assumptions fail and an instruction attempts to pop a value off of an empty stack an error will occur. This error is what's known as a stack underflow error. Stack will alert you when these errors occur and halt execution of the faulty program. Stack Signatures Because understanding how a given instruction will affect the stack is important to preventing errors in programs such as stack underflows many programming resources (including this one) will annotate instructions with stack signatures. Here is the stack signature for the add instruction. a b -- c Symbols to the left of the double-dash represent values that the instruction will pop off the stack, while symbols to the right of the double-dash represent values that the instruction will push onto the stack. This stack signature tells as the the add instruction expects two values a and b to be on the stack, and also that it will push a new value c onto the stack before the next instruction in executed. If two symbols in a stack signature are the same it means that their values will also be the same when executed. Consider the following stack signature. a -- a a This stack signature tells us that the instruction it is associated with will pop a single value off of the stack then push it back onto the stack twice. Symbols may be omitted from either side of the double-dash if no values are pushed or popped respectively. -- a This instruction pushes a value onto the stack but doesn't pop any values off it. a -- This instruction pops a value off of the stack but doesn't push any values onto it. -- This instruction doesn't push or pop any values onto the stack. The Stack (Continued) Since we currently have the values 10 and 5 on our stack the add instruction will push the integer value 15 onto the stack as 15 is the sum of 10 and 5. Stack: [ 15 ] The following instruction dup pops a value off of the stack and pushed the value back onto the stack twice. This essentially has the effect of duplicating the top-most value on the stack. Stack: [ 15 15 ] The next instruction * (otherwise known as the multiply instruction) functions similarly to the add instruction, only that it pushes the product of the two top-most values on the stack rather than their sum. Since we currently have the values 15 and 15 on our stack the multiply instruction will push the integer value 225 onto the stack as 225 is the product of 15 and 15. Stack: [ 225 ] Finally Stack will execute the final instruction printLine . The printLine instruction pops a value off of the stack and writes it to stdout, effectively displaying the value in your terminal instance.","title":"Stack Manipulation"},{"location":"stack-manipulation/#stack-manipulation","text":"","title":"Stack Manipulation"},{"location":"stack-manipulation/#the-stack","text":"Stacko maintains a list of values throughout its lifetime in a list known as the stack. Values can be appended ( pushed ) and removed ( popped ) from the stack at any time, but can only be done so in a last-in first-out ( LIFO ) order. Values on the stack may be used by certain instructions to perform calculations. These calculations may in turn push more values onto the stack. To understand this a bit better, lets look at the following example program. 10 5 + dup * printLine When Stacko begins to execute a new program it begins with an empty stack. Stack: [ ] Stack will then proceed to execute the first instruction in our program 10 . This instruction pushes the integer value 10 onto the stack. Stack: [ 10 ] The next instruction 5 likewise pushes the integer value 5 onto the stack. Stack: [ 10 5 ] Both the instructions we've seen so far have simply pushed new values onto the stack. The next instruction we'll look is the + instruction. The + instruction (otherwise known as the add instruction) pops two values off of the stack and then pushes their sum onto the stack.","title":"The Stack"},{"location":"stack-manipulation/#stack-underflow","text":"Instructions such as the add instruction may assume a certain number of values currently exist on the stack and can safely be popped off it. This, however, may not always be the case. Because the add instruction must pop two values off of the stack in order to perform its operation successfully, it must assume that at least 2 values exist on the stack when it is called. If these assumptions fail and an instruction attempts to pop a value off of an empty stack an error will occur. This error is what's known as a stack underflow error. Stack will alert you when these errors occur and halt execution of the faulty program.","title":"Stack Underflow"},{"location":"stack-manipulation/#stack-signatures","text":"Because understanding how a given instruction will affect the stack is important to preventing errors in programs such as stack underflows many programming resources (including this one) will annotate instructions with stack signatures. Here is the stack signature for the add instruction. a b -- c Symbols to the left of the double-dash represent values that the instruction will pop off the stack, while symbols to the right of the double-dash represent values that the instruction will push onto the stack. This stack signature tells as the the add instruction expects two values a and b to be on the stack, and also that it will push a new value c onto the stack before the next instruction in executed. If two symbols in a stack signature are the same it means that their values will also be the same when executed. Consider the following stack signature. a -- a a This stack signature tells us that the instruction it is associated with will pop a single value off of the stack then push it back onto the stack twice. Symbols may be omitted from either side of the double-dash if no values are pushed or popped respectively. -- a This instruction pushes a value onto the stack but doesn't pop any values off it. a -- This instruction pops a value off of the stack but doesn't push any values onto it. -- This instruction doesn't push or pop any values onto the stack.","title":"Stack Signatures"},{"location":"stack-manipulation/#the-stack-continued","text":"Since we currently have the values 10 and 5 on our stack the add instruction will push the integer value 15 onto the stack as 15 is the sum of 10 and 5. Stack: [ 15 ] The following instruction dup pops a value off of the stack and pushed the value back onto the stack twice. This essentially has the effect of duplicating the top-most value on the stack. Stack: [ 15 15 ] The next instruction * (otherwise known as the multiply instruction) functions similarly to the add instruction, only that it pushes the product of the two top-most values on the stack rather than their sum. Since we currently have the values 15 and 15 on our stack the multiply instruction will push the integer value 225 onto the stack as 225 is the product of 15 and 15. Stack: [ 225 ] Finally Stack will execute the final instruction printLine . The printLine instruction pops a value off of the stack and writes it to stdout, effectively displaying the value in your terminal instance.","title":"The Stack (Continued)"},{"location":"keyword-examples/file/","text":"File Description Include the contents of an external Stacko script in another Stack script. Recursive includes are automatically resolved by the Stacko interpreter. Example UserInfo.stko \"John Doe\" const userName Greeter.stko fnn greet { \"Hello \" print print \"!\" printLine } Main.stko file UserInfo . stko file Greeter . stko userName greet Result (Main.stko) Hello John Doe!","title":"File"},{"location":"keyword-examples/file/#file","text":"","title":"File"},{"location":"keyword-examples/file/#description","text":"Include the contents of an external Stacko script in another Stack script. Recursive includes are automatically resolved by the Stacko interpreter.","title":"Description"},{"location":"keyword-examples/file/#example","text":"UserInfo.stko \"John Doe\" const userName Greeter.stko fnn greet { \"Hello \" print print \"!\" printLine } Main.stko file UserInfo . stko file Greeter . stko userName greet Result (Main.stko) Hello John Doe!","title":"Example"},{"location":"keyword-examples/function/","text":"Function Description A function is an identifier which can be used to unconditionally invoke the execution of a series of instructions. Example fnn square { dup * } \"3 squared is \" print 3 square printLine Result 3 squared is 9","title":"Function"},{"location":"keyword-examples/function/#function","text":"","title":"Function"},{"location":"keyword-examples/function/#description","text":"A function is an identifier which can be used to unconditionally invoke the execution of a series of instructions.","title":"Description"},{"location":"keyword-examples/function/#example","text":"fnn square { dup * } \"3 squared is \" print 3 square printLine Result 3 squared is 9","title":"Example"},{"location":"keyword-examples/get-element/","text":"getElement Stack Signature list index -- elem Description Returns the element from a list list at index index . Example var nums [ 1 2 3 ] set nums \"nums[1] = \" print nums 1 getElement printLine Result nums[1] = 2","title":"getElement"},{"location":"keyword-examples/get-element/#getelement","text":"","title":"getElement"},{"location":"keyword-examples/get-element/#stack-signature","text":"list index -- elem","title":"Stack Signature"},{"location":"keyword-examples/get-element/#description","text":"Returns the element from a list list at index index .","title":"Description"},{"location":"keyword-examples/get-element/#example","text":"var nums [ 1 2 3 ] set nums \"nums[1] = \" print nums 1 getElement printLine Result nums[1] = 2","title":"Example"}]}